---
title: "Theta and DE"
author: "Thomas Quinn"
date: "March 20, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Here, I explore how differential proportionality (disjointed, $\theta$) relates to differential expression (DE). For this, I use a data set simulated with the R package `polyester`, aligned with Salmon, and mapped with quasi-counts.

Let us import the data and take a random sample of 10,000 genes:

```{r}
# Import simulated transcriptome and take random sample
txs <- read.csv("/home/thom/Dropbox/R/projects/manuscripts/bench/sim_hv_slQUASIout_counts.csv",
                row.names = 1)
rand <- sample(1:nrow(txs), 10000)
txs <- txs[rand, ]
txs[1:5, 1:5]
```

I will remove low counts from the data:

```{r}
keep <- apply(txs, 1, function(x) sum(x > 20) > 20)
txs <- txs[keep, ]
```

Since this is a simulated data set, we know *a priori* what is differentially expressed. This is available from a separate file:

```{r}
# Import known annotations
truth <- read.delim("/home/thom/Dropbox/R/projects/manuscripts/bench/hi-var/sim_tx_info.txt", row.names = 1)
rownames(truth) <- unlist(lapply(rownames(truth), function(x) strsplit(x, split = "\\s")[[1]][1]))
true <- truth[rownames(txs), ]
true[1:5, ]
```

We will calculate disjointed proportionality on the sample.

```{r}
library(propriety)
pd.tx <- propd(t(txs), group = c(rep("A", 20), rep("B", 20)))
```

Let us define a few functions for DE benchmarking. The first, `calcStats`, calculates precision and recall. The second, `simpleEdger`, runs a basic exact test using the DE software `edgeR`:

```{r}
calcStats <- function(obs, ref, what){

  all <- rownames(ref)
  tru <- rownames(ref)[ref$DEstatus.1]

  observed <- all %in% obs
  actual <- all %in% tru

  conf <- table(observed, actual)
  if(what == "precision"){
    out <- conf["TRUE", "TRUE"] / (conf["TRUE", "FALSE"] + conf["TRUE", "TRUE"])
  }else if(what == "recall"){
    out <- conf["TRUE", "TRUE"] / (conf["FALSE", "TRUE"] + conf["TRUE", "TRUE"])
  }
  return(out)
}

simpleEdger <- function(ct, group){

  library(edgeR)
  y <- DGEList(counts = ct, group = group)
  y <- calcNormFactors(y)
  y <- estimateCommonDisp(y)
  y <- estimateTagwiseDisp(y)
  et <- exactTest(y)
  tt <- as.data.frame(topTags(et, n = nrow(et)))
  deGenes <- rownames(tt)[tt$FDR < .05]
  plotSmear(et, de.tags = deGenes, cex = 0.5)
  return(deGenes)
}
```

Let us see how well $\theta$ selects for DE transcripts:

```{r, message = FALSE}
metrix <- lapply(c(50, 100, 200, 400, 800, 1600),
                 function(x){

                   check <- shale(pd.tx, cutoff = x, prompt = FALSE)
                   top <- union(check$PartnerName, check$PairName)
                   data.frame(calcStats(top, true, "precision"),
                              calcStats(top, true, "recall"))
                 })
do.call("rbind", metrix)
```

Not bad! How does this compare to `edgeR`?

```{r}
de <- simpleEdger(txs, group = c(rep("A", 20), rep("B", 20)))
calcStats(de, true, "precision")
calcStats(de, true, "recall")
```

Let us view the network to see which nodes (transcripts) get the wrong DE calls:

```{r, fig.keep = "last"}
# check <- shale(pd.tx, cutoff = 8000, prompt = FALSE)
# top <- union(check$PartnerName, check$PairName)
# table(true$foldchange.1)
# table(true[top, "foldchange.1"])
g <- plot(pd.tx, cutoff = 800, prompt = FALSE, col1 = rownames(true[true$foldchange.1 == 1,]))
```

Interestingly, most of the wrong DE calls occur in peripheral nodes with low connectivity. Does removing transcripts with only one connection improve precision?

```{r, fig.keep = "none", message = FALSE}
metrix <- lapply(c(50, 100, 200, 400, 800, 1600, 3200),
                 function(x){

                   g <- plot(pd.tx, cutoff = x, prompt = FALSE, col1 = rownames(true[true$foldchange.1 == 1,]))
                   d <- sort(igraph::degree(g), decreasing = TRUE)
                   top <- names(d[d != 1])
                   data.frame(calcStats(top, true, "precision"),
                              calcStats(top, true, "recall"))
                 })
do.call("rbind", metrix)
```

What about when we remove transcripts with less than 3 connections?

```{r, fig.keep = "none", message = FALSE}
metrix <- lapply(c(50, 100, 200, 400, 800, 1600, 3200),
                 function(x){

                   g <- plot(pd.tx, cutoff = x, prompt = FALSE, col1 = rownames(true[true$foldchange.1 == 1,]))
                   d <- sort(igraph::degree(g), decreasing = TRUE)
                   top <- names(d[d > 2])
                   data.frame(calcStats(top, true, "precision"),
                              calcStats(top, true, "recall"))
                 })
do.call("rbind", metrix)
```

Let us just consider transcripts in the top 30% as ranked by connectivity:

```{r, fig.keep = "none", message = FALSE}
metrix <- lapply(c(50, 100, 200, 400, 800, 1600, 3200),
                 function(x){

                   g <- plot(pd.tx, cutoff = x, prompt = FALSE, col1 = rownames(true[true$foldchange.1 == 1,]))
                   d <- sort(igraph::degree(g), decreasing = TRUE)
                   top <- names(d[1:(floor(length(d)*.3))])
                   data.frame(calcStats(top, true, "precision"),
                              calcStats(top, true, "recall"))
                 })
do.call("rbind", metrix)
```

There is an obvious relationship between disjointed proportionality and DE. Impressively, $\theta$ selects many DE events, and shows good precision and recall for calling DE, even though $\theta$ is not itself measure of differential expression! Is there a way to formalize $\theta$ to select DE more rigorously? If so, would we have on our hands the very first transformation-independent and sub-compositionally coherent measure of differential abundance?
